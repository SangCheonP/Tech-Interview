# 프로세스 & 스레드

## 프로세스 (Process)

    프로그램을 메모리 상에서 실행 중인 작업

### 프로세스의 특징

- 자원(CPU, 메모리 등)을 독립적으로 할당받아 실행

- 메모리 구조
    - **코드(Code)** 영역: 실행할 명령어가 저장
    - **데이터(Data)** 영역: 전역 변수, 정적 변수 등이 저장
    - **힙(Heap)** 영역: 동적으로 할당된 메모리 저장
    - **스택(Stack)** 영역: 함수 호출과 지역 변수 저장

- 프로세스 상태를 나타내는 정보를 **PCB(Process Control Block)**에 저장

- 각 프로세스는 독립적으로 실행되며 다른 프로세스의 메모리에 직접 접근할 수 없음
    - 다른 프로세스와 데이터를 교환하려면 **IPC(Inter-Process Communication)** 방식 사용

<br>

### 프로세스 생명 주기(Process Life Cycle)

<img src="https://thebook.io/img/080367/028.jpg">

#### New (생성)
- 프로세스가 생성되고 운영 체제에 등록된 상태
- 아직 준비 큐(Ready Queue)로 이동하지 않음

#### Ready (준비)
- 실행 준비가 완료된 상태
- CPU 할당을 기다리고 대기 중
- 여러 프로세스가 Ready Queue에 존재할 수 있음

#### Running (실행)
- CPU를 할당받아 실행 중인 상태
- 한 순간에는 하나의 프로세스만 CPU에서 실행됨(단일 코어 기준)
```
코어(Core)는 CPU(중앙처리장치)의 실행 단위로, 명령어를 처리하는 기본 구성 요소
단일 코어 : 순차적 처리
멀티 코어 : 병렬 처리
```

#### Waiting (대기)
- I/O 작업 또는 특정 이벤트를 기다리는 상태
- I/O 작업 완료 시 다시 Ready 상태로 전환

#### Terminated (종료)
- 작업이 완료되거나 강제로 종료된 상태
- 운영 체제는 프로세스를 제거하고 자원을 반환

```
Ready → Running: 스케줄러가 CPU를 할당
Running → Ready: CPU 시간이 끝나거나 더 높은 우선순위 작업이 도착
Running → Waiting: I/O 요청 또는 자원 대기
Waiting → Ready: 대기 작업이 완료
Running → Terminated: 작업 종료
```

<br>

### 프로세스 제어 블록(Process Control Block, PCB)

    프로세스에 대한 정보를 저장한 데이터 구조체로, 운영 체제가 프로세스를 관리하고 제어하는 데 사용

<br>

#### PCB 주요 구성 요소

<img src="https://cdn1.byjus.com/wp-content/uploads/2022/06/process-control-block.png">

- **프로세스 상태** : new, ready, running, waiting, terminated 등의 상태를 저장

- **프로세스 ID (PID)** : 프로세스 식별 번호

- **프로그램 카운터** : 프로세스가 다음에 실행할 명령어의 주소

- **CPU 레지스터, CPU 스케줄링 정보** : 프로세스의 우선순위, 스케줄 큐에 대한 포인터 등

- **메모리 관리 정보** : 페이지 테이블 또는 세그먼트 테이블 등과 같은 정보를 포함

- **어카운팅 정보** : 사용된 CPU 시간, 시간제한, 계정 번호 등

- **I/O 상태 정보** : 프로세스에 할당된 입출력 장치들과 열린 파일 목록

<br>

### 프로세스 간 전환(Context Switching)

    하나의 프로세스에서 다른 프로세스로 CPU를 교체하는 과정

<br>

#### Context Switching 과정
1. Running → Ready 또는 Waiting
    - 실행 중인 프로세스가 CPU 사용을 종료하거나 대기 상태로 전환

    - 현재 프로세스의 상태 정보를 PCB에 저장

2. Ready → Running
    - 스케줄러가 새 프로세스를 선택하여 CPU를 할당

    - 선택된 프로세스의 PCB 정보를 로드하여 실행

<br>

#### Context Switching의 단점
1. **오버헤드 발생**
    - Context Switching 동안 CPU는 현재 프로세스의 상태를 저장하고, 다른 프로세스의 상태를 복원하는 작업을 수행.

    - 이 과정에서 CPU는 실제 작업을 수행하지 않아 시스템 성능 저하로 이어질 수 있음.

    - 잦은 전환은 시간 낭비를 증가시키며 효율성을 저하.

2. **캐시 미스(Cache Miss)**
    - CPU는 자주 사용하는 데이터를 캐시에 저장하여 작업 속도를 높임.

    - Context Switching 시, 현재 프로세스의 캐시가 새로운 프로세스의 데이터로 덮어써짐.

    - 결과적으로 이전 프로세스가 재실행될 때 캐시 데이터를 다시 로드해야 하므로 **캐시 효율 감소 및 성능 저하 발생**.

3. **동기화 문제**
    - Context Switching이 빈번할 경우, 공유 자원에 대한 **동기화 문제**가 발생할 가능성이 증가.

    - 적절히 동기화되지 않은 경우, 다음과 같은 문제 발생:
        - **데드락(Deadlock)**: 여러 프로세스가 서로 자원을 기다리며 무한 대기.

        - **경쟁 상태(Race Condition)**: 여러 프로세스가 동시에 자원에 접근해 비정상적인 결과 발생.

<br>

## 스레드 (Thread)

    하나의 프로세스 내에서 실행되는 가장 작은 실행 단위

<br>

### 스레드의 특징

- 하나의 프로세스는 여러 스레드를 가질 수 있음

- 같은 프로세스 내 다른 스레드와 메모리 공간(코드, 데이터, 힙 등)을 공유

- 각각의 스레드는 독립적인 스택과 레지스터를 가짐

<br>

## 멀티 스레드 (Multi-Threading)

    하나의 프로세스가 둘 이상의 스레드를 생성하여 동시에 실행하는 것

<img src="https://user-images.githubusercontent.com/22395934/71546354-6c4f4d80-29d9-11ea-8784-5d3fc534e3ea.png">

<br>

### 멀티 스레드의 장점

- **자원을 효율적으로 사용**
    - 같은 메모리 공간을 공유하므로 새로운 프로세스를 생성하는 것보다 오버헤드가 적음

- **빠른 작업 처리**
    - 여러 작업을 동시에 실행하여 성능을 높임

- **사용자 경험 향상**
    - 작업 중 화면이 멈추거나 응답하지 않는 상황을 줄임

<br>

### 멀티 스레드의 단점

- **동기화 문제**
    - 여러 스레드가 공유 자원에 접근하면 경쟁 상태(Race Condition) 또는 데드락(Deadlock)이 발생할 수 있음

- **CPU 오버헤드**
    - 스레드 간의 문맥 전환(Context Switching)으로 CPU 오버헤드가 발생

<br>

## 요약

```
멀티 프로세스 : 독립적인 메모리 공간을 사용하며 안정성이 높지만, 오버헤드와 통신 비용이 큼
멀티 스레드 : 메모리를 공유하며 가볍고 빠르지만, 동기화 문제와 안정성 위험이 있음
```