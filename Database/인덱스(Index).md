# 인덱스(Index)

## 인덱스(Index)란?
```
데이터베이스에서 데이터를 신속하게 검색하기 위한 데이터 구조로 
책의 목차처럼, 테이블에서 필요한 데이터를 빠르게 찾을 수 있도록 도움

* 주로 B-Tree 또는 Hash 구조로 구현
```

<br>
<hr>

### 사용하는 이유
- 대량의 데이터가 저장된 테이블에서 **데이터를 효율적으로 검색**하기 위해 사용

- **Full Table Scan을 줄여서 쿼리 성능을 향상**

- 자주 조회되는 컬럼에 인덱스를 적용하면, WHERE, JOIN, ORDER BY, GROUP BY 조건에서 **성능 개선**을 제공

<br>
<hr>

### 장점
1. **검색 성능 향상**
    - 특정 조건에 맞는 데이터를 빠르게 찾을 수 있음

2. **시스템 부하 감소**
    - Full Table Scan 대신 특정 레코드만 읽으므로 CPU와 디스크 I/O 사용량이 감소

3. **정렬 및 그룹화 속도 개선**
    - ORDER BY나 GROUP BY 쿼리에서 효율성을 높임

<br>
<hr>

### 단점
1. **쓰기 성능 저하**
    - 데이터 삽입, 수정, 삭제 시 인덱스도 갱신되어야 하므로 작업 속도가 느려질 수 있음

2. **추가 저장 공간 필요**
    - 인덱스는 테이블 외에도 별도의 저장 공간을 차지함

3. **과도한 인덱스는 역효과**
    - 불필요한 인덱스가 많아지면 오히려 성능이 저하될 수 임

<br>
<hr>

### 유형
#### 프라이머리 인덱스 (Primary Index)
- 프라이머리 인덱스는 **기본 키(Primary Key)**나 **클러스터드 키(Clustered Key)**에 의해 생성됨

- **클러스터드 인덱스(Clustered Index)**라고도 불리며, 테이블의 데이터가 물리적으로 **정렬된 상태로 저장됨**

- 한 테이블에는 **하나의 프라이머리 인덱스만 존재할 수 있음**

##### 작동 방식
- 데이터가 실제 테이블에 저장될 때, 프라이머리 인덱스의 정렬 기준에 따라 데이터가 물리적으로 정렬됨

- 프라이머리 인덱스를 통해 데이터를 검색하면, 데이터에 직접 접근하므로 빠른 검색 속도를 제공


##### 장점
- 데이터 검색 속도가 매우 빠름

- 범위 검색(BETWEEN, >, <)에 최적화되어 있음


##### 단점
- 데이터가 삽입, 수정, 삭제될 때 물리적인 데이터 정렬이 필요하므로 **쓰기 작업의 성능이 저하**될 수 있음

<br>
<hr>

#### 세컨더리 인덱스 (Secondary Index)
- 세컨더리 인덱스는 프라이머리 인덱스 이외의 컬럼에 대해 생성된 인덱스

- **비클러스터드 인덱스(Non-Clustered Index)**라고도 불리며, 데이터와 인덱스가 별도로 저장

- 테이블에 여러 개의 세컨더리 인덱스를 생성할 수 있음

##### 작동 방식
- 세컨더리 인덱스는 프라이머리 인덱스를 참조하여 데이터의 위치를 확인함

- 데이터를 검색할 때 세컨더리 인덱스를 먼저 조회하고, 인덱스를 통해 프라이머리 인덱스를 참조하여 실제 데이터를 가져옴

##### 장점
- 다양한 컬럼에 대해 인덱스를 생성할 수 있어 검색 조건에 유연하게 대응할 수 있음

- 프라이머리 인덱스가 아닌 컬럼에서도 빠른 검색이 가능함

##### 단점
- 데이터를 검색할 때 세컨더리 인덱스와 프라이머리 인덱스를 두 번 접근해야 하므로 프라이머리 인덱스보다 약간 느림

- 추가적인 저장 공간이 필요

<br>
<hr>

### 작동방식
1. **B-Tree 기반** 인덱스
    - 데이터가 **정렬된 상태**로 유지됨
    - **범위 검색과 순차 검색에 적합**
    - **대부분의 관계형 데이터베이스**에서 기본 인덱스 구조로 사용됨

2. **Hash 기반** 인덱스
    - **정확한 값 매칭(=) 검색에 최적화**되어 있습니다.
    - 범위 검색에는 적합하지 않습니다.