# 🏆 플로이드-워셜 알고리즘 (Floyd-Warshall Algorithm)

## 📌 개요
플로이드-워셜 알고리즘은 **모든 정점 간 최단 거리(경로)를 구하는 알고리즘**입니다.  
특정 시작점에서 목표점까지의 최단 경로를 찾는 다익스트라 알고리즘과는 다르게, **모든 노드 간의 최소 비용을 한 번에 구할 때 유용**합니다.

---
<br>

## 🛠️ 언제 사용할까?
✔ **모든 노드 간 최단 경로를 한 번에 구해야 할 때**  
✔ **그래프의 노드 개수가 작고(100 이하), 간선이 많을 때**  
✔ **음수 가중치가 존재하지만, 음수 사이클이 없는 경우**  
✔ **경로 복원을 수행해야 할 때 (경로 추적 가능)** 

📌 즉, "N이 100 이하이고 모든 정점 간의 최단 경로를 구해야 할 때" 사용

---
<br>

## 📊 시간 복잡도 & 사용할 수 있는 최대 N 값
- 시간 복잡도: **O(N³)**
- 공간 복잡도: **O(N²)**
- N의 크기: **최대 100까지 가능** (N=500 이상이면 사용 어려움)

| 알고리즘 | 시간 복잡도 | 최대 N |
|----------|------------|--------|
| 다익스트라(우선순위 큐) | O((V + E) log V) | 약 100,000 |
| 벨만-포드 | O(VE) | 약 5,000 |
| 플로이드-워셜 | O(N³) | 약 100 |

**🔹 다익스트라는 한 정점에서 다른 모든 정점까지의 최단 경로를 구할 때 사용**  
**🔹 플로이드-워셜은 모든 정점 간의 최단 경로를 구할 때 사용**  

---
<br>

## 🔎 동작 방식
1. **그래프를 인접 행렬로 표현하고, 최단 거리 배열을 초기화**
   - `graph[i][j]`에 **i에서 j까지 가는 비용**을 저장
   - 간선이 없으면 `INF(무한대)`로 설정

2. **모든 정점 k를 중간 경유지로 설정하여 i → k → j 경로를 갱신**
   - 기존 `i → j`보다 `i → k → j`가 더 짧다면 값을 갱신

3. **모든 노드 쌍(i, j)에 대해 반복하며 최적 경로를 찾음**

---
<br>

## 🧑‍💻 예제 코드 (Java)
```java
import java.util.Arrays;

public class FloydWarshall {
    static final int INF = 1000000000; // 무한대 값 설정

    public static void main(String[] args) {
        int n = 4; // 노드 개수
        int[][] graph = {
            {0, 3, INF, 5},
            {2, 0, INF, 4},
            {INF, 1, 0, INF},
            {INF, INF, 2, 0}
        };

        floydWarshall(n, graph);
    }

    public static void floydWarshall(int n, int[][] graph) {
        // 거리 배열 복사
        int[][] dist = new int[n][n];
        for (int i = 0; i < n; i++) {
            dist[i] = Arrays.copyOf(graph[i], n);
        }

        // 플로이드-워셜 알고리즘 수행
        for (int k = 0; k < n; k++) { // 중간 노드
            for (int i = 0; i < n; i++) { // 출발 노드
                for (int j = 0; j < n; j++) { // 도착 노드
                    if (dist[i][k] != INF && dist[k][j] != INF) {
                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
                    }
                }
            }
        }

        // 결과 출력
        printGraph(dist, n);
    }

    public static void printGraph(int[][] graph, int n) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (graph[i][j] == INF) System.out.print("INF ");
                else System.out.print(graph[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```

---
<br>

## 🏆 예제 입력 & 출력
**💡 입력 그래프**  
```plaintext
4  (노드 개수)
0 3 INF 5
2 0 INF 4
INF 1 0 INF
INF INF 2 0
```

**✅ 플로이드-워셜 알고리즘 수행 후 결과**
```plaintext
0 3 7 5
2 0 6 4
3 1 0 5
5 3 2 0
```
각 노드 간의 최단 경로가 업데이트됨!

---
<br>

## 🏅 응용 사례
1. **경쟁 순위 계산** (ex: 프로그래머스 '순위' 문제)
   - 특정 사람이 다른 사람을 이긴/진 관계를 분석하여 정확한 순위 산정  
2. **도로 네트워크 최적화**
   - 도시 간 도로망에서 최단 경로를 찾을 때 사용  
3. **네트워크 경로 최적화**
   - 패킷이 최단 거리로 전송될 수 있도록 경로 설정  

---
<br>

## 🎯 요약
✔ **모든 정점 간 최단 거리 구하는 알고리즘**  
✔ **O(N³) 시간 복잡도를 가지므로 N ≤ 100일 때 사용 가능**  
✔ **다익스트라와 달리 모든 노드 쌍을 처리하므로 전체 최단 경로를 구할 때 유용**  
✔ **경로 복원이 가능하여 특정 문제에서도 활용 가능** 🚀
